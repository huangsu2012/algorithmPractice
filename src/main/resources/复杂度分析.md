##为什么要做复杂度分析
> 相比较于通过执行代码统计程序执行时间的方式  
>1、复杂度分析可以脱离具体的执行环境影响  
>2、复杂度分析可以脱离数据规模的影响  

简而言之就是当我们需要在没有测试数据的情况下粗略估计算法执行效率，就需要做复杂度分析  
##大O复杂度表示法
![alt 大o复杂度公司](大o时间复杂度公式.png)
T(n)表示代码执行时间，f(n)表示每行代码执行次数总和，n表示数据规模大小，O表达的是T(n)与f(n)成正比。  
大O时间复杂度不表示代码执行的真正时间，而是代码执行时间与数据规模增长的变化趋势，因此也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。  
当 n 很大时，公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了。
##时间复杂度分析方法
###1、只关注循环执行次数最多的一段代码
其实就是找到循环代码
###2、加法法则：总复杂度等于量级最大的那段代码的复杂度
如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).  
其实就是当有多个循环时，找循环次数最多的代码
###3、乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n)).  
这个一般用来计算嵌套循环的执行时间复杂度

##常见时间复杂度量级公式
###多项式量级
O(1):  
表示执行时间不随n增长而变化，一般只要算法中没有循环语句或者循环语句循环次数与n无关，递归语句或者递归次数与n无关
O(logn),O(n),O(nlogn),O(n^2),O(n^3),O(n^k)
###非多项式量级
O(2^n),O(n!)
我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。

##多种时间复杂度分析
样例代码：
```样例1 
// n表示数组array的长度
  find(int[] array, int n, int x) {
    int i = 0;
    int pos = -1;
    for (; i < n; ++i) {
      if (array[i] == x) {
        pos = i;
        break;
      }
    }
    return pos;
  }
```
```样例2
  int[] array = new int[n];
  int count = 0;

  void insert(int val) {
    if (count == array.length) {
      int sum = 0;
      for (int i = 0; i < array.length; ++i) {
        sum = sum + array[i];
      }
      array[0] = sum;
      count = 1;
    }
    array[count] = val;
    ++count;
  }
```
###最好情况时间复杂度
指的是最好情况下算法的时间复杂度，比如样例1的代码，最好情况下其时间复杂度为O(1),刚好第一个元素就是要查找的元素
###最坏情况时间复杂度
指的是最坏情况下算法的时间复杂度，比如样例1的代码，最坏情况下其时间复杂度为O(n)，要查找的元素不在数组中
###平均时间复杂度
又叫加权平均时间复杂度，设各种情况出现的概率为p<sub>i</sub>,时间为t<sub>i</sub>(i的值为0～n),则时间复杂度为O(sum(p<sub>i</sub>*t<sub>i</sub>))
###均摊时间复杂度
对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，  
这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。  
而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。  
均摊时间复杂度就是一种特殊的平均时间复杂度  
比如样例2，大部分情况下插入操作耗时都为O(1)，只有在数组满了的时候，此时再插入数据的时候其耗时才为O(n)，也就是昂贵的插入操作都发生在n-1个O(1)的插入操作后